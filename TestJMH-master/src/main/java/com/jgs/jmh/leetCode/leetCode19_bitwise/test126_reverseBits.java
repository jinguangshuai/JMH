package com.jgs.jmh.leetCode.leetCode19_bitwise;

/**
 * @Auther：jinguangshuai
 * @Data：2024/5/24 - 05 - 24 - 15:08
 * @Description:com.jgs.jmh.leetCode19_bitwise
 * @version:1.0
 */

/**
 * * 颠倒给定的 32 位无符号整数的二进制位。
 * <p>
 * 提示：
 * <p>
 * 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，
 * * 并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
 * 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。
 */
public class test126_reverseBits {
    //将n视作一个长为32的二进制串，从低位往高位枚举n的每一位，将其倒序添加到翻转结果result中。
    public static int reverseBits1(int n) {
        int result = 0;
        // 单个二进制码 n & 1 等于自身二进制码 左移31-i位，即完成第i位的翻转
        // n >>>= 1 n逻辑向右移动一位
        for (int i = 0; i < 32 && n != 0; i++) {
            result = result | ((n & 1) << (31 - i));
            n >>>= 1;
        }
        return result;
    }

    //对于递归的最底层，我们需要交换所有奇偶位：取出所有奇数位和偶数位；
    //将奇数位移到偶数位上，偶数位移到奇数位上。
    //类似地，对于倒数第二层，每两位分一组，
    //按组号取出所有奇数组和偶数组，然后将奇数组移到偶数组上，偶数组移到奇数组上。以此类推。
    //原数据为:12345678
    //第一轮 奇偶位交换 21436587
    //第二轮 每两位交换 43218765
    //第三轮 每四位交换 87654321

    static int M1 = 0x55555555; // 01010101010101010101010101010101
    static int M2 = 0x33333333; // 00110011001100110011001100110011
    static int M4 = 0x0f0f0f0f; // 00001111000011110000111100001111
    static int M8 = 0x00ff00ff; // 00000000111111110000000011111111
    public static int reverseBits2(int n) {
        // n>>>1右移，将n上原来的偶数位变为奇数位，但是奇数位没有变成偶数位，因为右移将第一个奇数位移除
        // n>>>1 & M1将n>>>1的奇数位提取出来，也就是原来n的偶数位
        //(n & M1) << 1 先将n的奇数位提取出来，变成偶数位
        // 奇数位（原n的偶数位） | 偶数位（原n的奇数位） 进行相或运算，达到原n的奇数位和偶数位互换的效果
        n = n >>> 1 & M1 | (n & M1) << 1;
        n = n >>> 1 & M2 | (n & M2) << 2;
        n = n >>> 1 & M4 | (n & M4) << 4;
        n = n >>> 1 & M8 | (n & M8) << 8;
        return n >>> 16 | n << 16;
    }


    public static void main(String[] args) {
        int n = -3;
        System.out.println(reverseBits2(n));
    }
}
